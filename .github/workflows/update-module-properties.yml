name: Update Module Properties

# This workflow runs in the modules-untouched repository
# It automatically updates modules/MODULE.properties files when a release is created or edited

on:
  release:
    types: [published, edited]

  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to process (e.g., php-2025.10.31)'
        required: true

jobs:
  update-properties:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install requests packaging

      - name: Extract module name and update properties
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          python << 'EOF'
          import os
          import re
          import requests
          from packaging import version
          from collections import OrderedDict

          # Get environment variables
          release_tag = os.environ['RELEASE_TAG']
          repo_owner = os.environ['REPO_OWNER']
          repo_name = os.environ['REPO_NAME']
          github_token = os.environ['GITHUB_TOKEN']

          print(f"Processing release: {release_tag}")

          # Extract module name from tag (e.g., "php-2025.10.31" -> "php")
          module_match = re.match(r'^([a-zA-Z0-9_-]+)-\d{4}\.\d{1,2}\.\d{1,2}', release_tag)
          if not module_match:
              print(f"ERROR: Could not extract module name from tag: {release_tag}")
              print("Expected format: MODULENAME-YYYY.MM.DD (e.g., php-2025.10.31)")
              exit(1)

          module_name = module_match.group(1).lower()
          print(f"Module name: {module_name}")

          # Save module name for next steps (do this early in case of errors)
          with open('module_name.txt', 'w') as f:
              f.write(module_name)

          # Construct API URL
          api_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/releases/tags/{release_tag}"

          headers = {
              'Authorization': f'token {github_token}',
              'Accept': 'application/vnd.github.v3+json'
          }

          print(f"Fetching release information from: {api_url}")

          # Fetch release data
          response = requests.get(api_url, headers=headers)
          response.raise_for_status()
          release_data = response.json()

          # Extract version from release title/name (fallback for all modules)
          release_name_version = None
          release_name = release_data.get('name', '')
          if release_name:
              # Try to extract version from release name (supports 2-5+ part versions: X.Y, X.Y.Z, X.Y.Z.W, etc.)
              version_match = re.search(r'(\d+(?:\.\d+)+)', release_name)
              if version_match:
                  release_name_version = version_match.group(1)
                  print(f"Found version in release name: {release_name_version}")

          # Extract assets
          # Special handling for:
          # - composer: uses .phar files
          # - xlight: version in release name
          # - mailpit: version in release name (files named mailpit-windows-amd64.zip)
          # - git: files start with "portable"
          # - nodejs: files start with "node-" instead of "nodejs"
          # - cmder: accepts cmder.7z or cmder_mini.zip (version from release name)
          # - ghostscript: version embedded without dots (e.g., gs10051w64.7z for version 10.05.1)
          assets = []
          for asset in release_data.get('assets', []):
              filename = asset['name']

              # For composer, accept any .phar file (doesn't need to start with "composer")
              # For xlight, accept xlight-x64.zip (version comes from release name)
              # For git, files start with "portable" instead of "git"
              # For nodejs, files start with "node-" instead of "nodejs"
              # For other modules, file must start with module name
              if module_name == 'composer':
                  if filename.endswith('.phar'):
                      download_url = asset['browser_download_url']
                      # Try to extract version from filename first, then fall back to release name
                      version_match = re.search(r'(\d+(?:\.\d+)+)', filename)
                      if version_match:
                          ver = version_match.group(1)
                      elif release_name_version:
                          ver = release_name_version
                      else:
                          print(f"ERROR: Could not extract version for composer from release name or filename: {filename}")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          exit(1)
                      assets.append({
                          'version': ver,
                          'url': download_url,
                          'filename': filename
                      })
                      print(f"Found: {filename} -> Version: {ver}")
              elif module_name == 'xlight':
                  # For xlight, look for xlight-x64.zip and use version from release name
                  if filename == 'xlight-x64.zip':
                      download_url = asset['browser_download_url']
                      if release_name_version:
                          ver = release_name_version
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver}")
                      else:
                          print(f"ERROR: Could not extract version for xlight from release name")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          exit(1)
              elif module_name == 'mailpit':
                  # For mailpit, look for mailpit-windows-amd64.zip and use version from release name
                  if filename == 'mailpit-windows-amd64.zip':
                      download_url = asset['browser_download_url']
                      if release_name_version:
                          ver = release_name_version
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver}")
                      else:
                          print(f"ERROR: Could not extract version for mailpit from release name")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          exit(1)
              elif module_name == 'git':
                  # For git, files start with "portable" instead of "git"
                  # Accept files with .7z, .exe, .zip extensions (including double extensions like .7z.exe)
                  if filename.lower().startswith('portable'):
                      # Check if file has valid extension (including double extensions)
                      valid_ext = (filename.endswith('.7z') or filename.endswith('.exe') or
                                   filename.endswith('.zip') or filename.endswith('.7z.exe'))
                      if valid_ext:
                          download_url = asset['browser_download_url']

                          # Try to extract version from filename first, then fall back to release name
                          version_match = re.search(r'(\d+(?:\.\d+)+)', filename)
                          if version_match:
                              ver = version_match.group(1)
                              assets.append({
                                  'version': ver,
                                  'url': download_url,
                                  'filename': filename
                              })
                              print(f"Found: {filename} -> Version: {ver} (from filename)")
                          elif release_name_version:
                              ver = release_name_version
                              assets.append({
                                  'version': ver,
                                  'url': download_url,
                                  'filename': filename
                              })
                              print(f"Found: {filename} -> Version: {ver} (from release name)")
                          else:
                              print(f"ERROR: Could not extract version for git from release name or filename: {filename}")
                              print(f"Release name: {release_data.get('name', 'N/A')}")
                              exit(1)
              elif module_name == 'nodejs':
                  # For nodejs, files start with "node-" instead of "nodejs"
                  # Accept files with .7z, .exe, .zip extensions
                  if filename.lower().startswith('node-'):
                      # Check if file has valid extension
                      valid_ext = (filename.endswith('.7z') or filename.endswith('.exe') or filename.endswith('.zip'))
                      if valid_ext:
                          download_url = asset['browser_download_url']

                          # Try to extract version from filename first, then fall back to release name
                          version_match = re.search(r'(\d+(?:\.\d+)+)', filename)
                          if version_match:
                              ver = version_match.group(1)
                              assets.append({
                                  'version': ver,
                                  'url': download_url,
                                  'filename': filename
                              })
                              print(f"Found: {filename} -> Version: {ver} (from filename)")
                          elif release_name_version:
                              ver = release_name_version
                              assets.append({
                                  'version': ver,
                                  'url': download_url,
                                  'filename': filename
                              })
                              print(f"Found: {filename} -> Version: {ver} (from release name)")
                          else:
                              print(f"ERROR: Could not extract version for nodejs from release name or filename: {filename}")
                              print(f"Release name: {release_data.get('name', 'N/A')}")
                              exit(1)
              elif module_name == 'cmder':
                  # For cmder, accept cmder.7z or cmder_mini.zip (version comes from release name)
                  if filename.lower() in ['cmder.7z', 'cmder_mini.zip']:
                      download_url = asset['browser_download_url']
                      if release_name_version:
                          ver = release_name_version
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver}")
                      else:
                          print(f"ERROR: Could not extract version for cmder from release name")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          exit(1)
              elif module_name == 'ghostscript':
                  # For ghostscript, files are named like gs10051w64.7z where 10051 = version 10.05.1
                  # Pattern: gs + version_without_dots + w32/w64 + .7z
                  if filename.lower().startswith('gs') and filename.endswith('.7z'):
                      download_url = asset['browser_download_url']

                      # Extract the numeric part between 'gs' and 'w32'/'w64'
                      # Example: gs10051w64.7z -> 10051
                      match = re.match(r'gs(\d+)w(?:32|64)\.7z', filename.lower())
                      if match:
                          version_digits = match.group(1)
                          # Convert version digits to proper version format
                          # Examples: 922 -> 9.22, 9561 -> 9.56.1, 10051 -> 10.05.1, 1000 -> 10.0
                          if len(version_digits) == 3:
                              # Format: XYZ -> X.YZ (e.g., 922 -> 9.22)
                              ver = f"{version_digits[0]}.{version_digits[1:]}"
                          elif len(version_digits) == 4:
                              if version_digits.startswith('10'):
                                  # Format: 10XY -> 10.X.Y or 10.XY (e.g., 1000 -> 10.0, 1003 -> 10.03)
                                  if version_digits[2:] == '00':
                                      ver = f"10.{version_digits[2]}"  # 1000 -> 10.0
                                  else:
                                      ver = f"10.{version_digits[2:]}"  # 1003 -> 10.03
                              else:
                                  # Format: XYZW -> X.YZ.W (e.g., 9561 -> 9.56.1)
                                  ver = f"{version_digits[0]}.{version_digits[1:3]}.{version_digits[3]}"
                          elif len(version_digits) == 5:
                              # Format: 10XYZ -> 10.XY.Z (e.g., 10051 -> 10.05.1, 10020 -> 10.02.0)
                              ver = f"10.{version_digits[2:4]}.{version_digits[4]}"
                          else:
                              print(f"WARNING: Unexpected version digit length for ghostscript: {version_digits}")
                              if release_name_version:
                                  ver = release_name_version
                              else:
                                  print(f"ERROR: Could not parse version from filename: {filename}")
                                  continue

                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver} (parsed from filename)")
                      elif release_name_version:
                          # Fallback to release name version
                          ver = release_name_version
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver} (from release name)")
                      else:
                          print(f"ERROR: Could not extract version for ghostscript from filename: {filename}")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          exit(1)
              elif filename.lower().startswith(module_name):
                  # Standard modules use .7z, .exe, or .zip and must start with module name (case-insensitive)
                  if filename.endswith('.7z') or filename.endswith('.exe') or filename.endswith('.zip'):
                      download_url = asset['browser_download_url']

                      # Try to extract version from filename first, then fall back to release name
                      # For Ruby, extract full version including build number (e.g., 3.4.7-1 from rubyinstaller-3.4.7-1-x64.7z)
                      if module_name == 'ruby':
                          version_match = re.search(r'(\d+(?:\.\d+)+(?:-\d+)?)', filename)
                      else:
                          version_match = re.search(r'(\d+(?:\.\d+)+)', filename)

                      if version_match:
                          ver = version_match.group(1)
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver} (from filename)")
                      elif release_name_version:
                          ver = release_name_version
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver} (from release name)")
                      else:
                          print(f"\n{'='*60}")
                          print(f"ERROR: Could not extract version for {module_name}")
                          print(f"{'='*60}")
                          print(f"Module name: {module_name}")
                          print(f"Release tag: {release_tag}")
                          print(f"Release name: {release_data.get('name', 'N/A')}")
                          print(f"Asset filename: {filename}")
                          print(f"Asset URL: {download_url}")
                          print(f"\nVersion extraction attempts:")
                          print(f"  1. Filename regex pattern: r'(\\d+(?:\\.\\d+)+)'")
                          print(f"     Matches: X.Y, X.Y.Z, X.Y.Z.W, etc. (2+ parts)")
                          print(f"     Result: No match found in '{filename}'")
                          print(f"  2. Release name: '{release_data.get('name', 'N/A')}'")
                          print(f"     Result: No version found")
                          print(f"\nAll assets in this release:")
                          for idx, a in enumerate(release_data.get('assets', []), 1):
                              print(f"  {idx}. {a['name']}")
                          print(f"{'='*60}\n")
                          exit(1)

          if not assets:
              if module_name == 'composer':
                  print(f"No .phar assets found in release")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'xlight':
                  print(f"No xlight-x64.zip asset found in release")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'mailpit':
                  print(f"No mailpit-windows-amd64.zip asset found in release")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'git':
                  print(f"No valid assets found in release")
                  print(f"Expected: .7z, .exe, or .zip files starting with 'portable'")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'nodejs':
                  print(f"No valid assets found in release")
                  print(f"Expected: .7z, .exe, or .zip files starting with 'node-'")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'cmder':
                  print(f"No valid cmder assets found in release")
                  print(f"Expected: cmder.7z or cmder_mini.zip")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              elif module_name == 'ghostscript':
                  print(f"No valid ghostscript assets found in release")
                  print(f"Expected: .7z files matching pattern gs<version>w32/w64.7z")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              else:
                  print(f"No .7z, .exe, or .zip assets found starting with '{module_name}' in release")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              exit(0)

          # Read existing properties file
          properties_file = f"modules/{module_name}.properties"

          if not os.path.exists(properties_file):
              print(f"ERROR: Properties file not found: {properties_file}")
              print(f"The properties file must already exist in the repository.")
              exit(1)

          print(f"Reading existing properties file: {properties_file}")
          with open(properties_file, 'r', encoding='utf-8') as f:
              lines = f.readlines()

          print(f"File contents ({len(lines)} lines):")
          for i, line in enumerate(lines, 1):
              print(f"  {i}: {line.rstrip()}")

          # Parse existing properties
          properties = OrderedDict()
          header_lines = []
          in_header = True

          for line in lines:
              stripped = line.strip()
              if in_header and (stripped.startswith('#') or stripped == ''):
                  header_lines.append(line)
              else:
                  in_header = False
                  if '=' in line and not stripped.startswith('#'):
                      key, value = line.split('=', 1)
                      properties[key.strip()] = value.strip()

          print(f"\nExisting properties before update: {len(properties)} entries")
          for key, value in properties.items():
              print(f"  {key} = {value}")

          # Track if any changes were made
          changes_made = False
          added_versions = []
          updated_versions = []

          # Add new versions
          for asset in assets:
              ver = asset['version']
              url = asset['url']

              # Create property key (just version number)
              key = ver

              # Check if this is a new version or an update
              if key in properties:
                  if properties[key] != url:
                      updated_versions.append(f"{key}: {properties[key]} -> {url}")
                      properties[key] = url
                      changes_made = True
                      print(f"Updated: {key} = {url}")
                  else:
                      print(f"Unchanged: {key} = {url} (already exists with same URL)")
              else:
                  added_versions.append(f"{key} = {url}")
                  properties[key] = url
                  changes_made = True
                  print(f"Added: {key} = {url}")

          # Check if any changes were actually made
          if not changes_made:
              print(f"\n{'='*70}")
              print(f"ERROR: No changes were made to {properties_file}")
              print(f"{'='*70}")
              print(f"\nRelease Information:")
              print(f"  Release Tag: {release_tag}")
              print(f"  Release Name: {release_data.get('name', 'N/A')}")
              print(f"  Module: {module_name}")
              print(f"\nAssets Found in Release:")
              for idx, asset in enumerate(assets, 1):
                  print(f"  {idx}. {asset['filename']}")
                  print(f"     Version: {asset['version']}")
                  print(f"     URL: {asset['url']}")
              print(f"\nExisting Properties File Content:")
              print(f"  File: {properties_file}")
              print(f"  Total entries: {len(properties)}")
              for key, value in properties.items():
                  print(f"    {key} = {value}")
              print(f"\nReason:")
              print(f"  All versions from this release already exist in the properties file")
              print(f"  with the same URLs. No updates are needed.")
              print(f"\nPossible Causes:")
              print(f"  1. This release was already processed previously")
              print(f"  2. The properties file was manually updated with these versions")
              print(f"  3. The workflow was re-run on the same release")
              print(f"\nAction Required:")
              print(f"  If this is unexpected, verify:")
              print(f"  - The release contains new assets not in the properties file")
              print(f"  - The asset filenames match the expected pattern for {module_name}")
              print(f"  - The version extraction logic is working correctly")
              print(f"{'='*70}\n")
              exit(1)

          # Sort properties by version (semver)
          def extract_version(key):
              # Parse version directly from key
              try:
                  return version.parse(key)
              except:
                  return version.parse("0.0.0")

          sorted_properties = OrderedDict(
              sorted(properties.items(), key=lambda x: extract_version(x[0]), reverse=True)
          )

          # Write back to file
          with open(properties_file, 'w', encoding='utf-8') as f:
              # Write header
              for line in header_lines:
                  f.write(line)

              # Write sorted properties with spaces around equals sign
              for key, value in sorted_properties.items():
                  f.write(f"{key} = {value}\n")

          print(f"\n{'='*70}")
          print(f"SUCCESS: Updated {properties_file}")
          print(f"{'='*70}")
          print(f"Total versions in file: {len(sorted_properties)}")

          if added_versions:
              print(f"\nAdded {len(added_versions)} new version(s):")
              for ver in added_versions:
                  print(f"  + {ver}")

          if updated_versions:
              print(f"\nUpdated {len(updated_versions)} existing version(s):")
              for ver in updated_versions:
                  print(f"  ~ {ver}")

          print(f"{'='*70}\n")

          EOF

      - name: Read module name
        id: module_info
        if: always()
        run: |
          if [ -f module_name.txt ]; then
            MODULE_NAME=$(cat module_name.txt)
            echo "module_name=$MODULE_NAME" >> $GITHUB_OUTPUT
          else
            echo "module_name=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_PAT }}
          base: main
          commit-message: |
            Update ${{ steps.module_info.outputs.module_name }} module properties

            Auto-generated from release ${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          branch: update-${{ steps.module_info.outputs.module_name }}-${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          delete-branch: true
          title: 'Update ${{ steps.module_info.outputs.module_name }} properties from release ${{ github.event.release.tag_name || github.event.inputs.release_tag }}'
          body: |
            ## ü§ñ Automated Module Properties Update

            This PR updates the `${{ steps.module_info.outputs.module_name }}.properties` file with new versions from release `${{ github.event.release.tag_name || github.event.inputs.release_tag }}`.

            ### Changes:
            - Extracted assets starting with `${{ steps.module_info.outputs.module_name }}` (.7z, .exe, or .zip files)
            - Added version entries with download URLs
            - Maintained semver ordering (newest first)

            **Release URL:** ${{ github.event.release.html_url || format('https://github.com/{0}/{1}/releases/tag/{2}', github.repository_owner, github.event.repository.name, github.event.inputs.release_tag) }}

            ### Next Steps:
            1. ‚è≥ Link validation will run automatically
            2. ‚úÖ Once validation passes, this PR will auto-merge
            3. ‚ùå If validation fails, please review and fix invalid URLs
          labels: |
            automated
            module-update

      - name: Wait for validation checks
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          echo "Waiting for link validation to complete..."
          sleep 10

      - name: Enable auto-merge
        if: steps.create_pr.outputs.pull-request-number != ''
        run: |
          gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --squash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Cleanup
        if: always()
        run: |
          if [ -f module_name.txt ]; then
            rm module_name.txt
            echo "Cleaned up module_name.txt"
          fi
