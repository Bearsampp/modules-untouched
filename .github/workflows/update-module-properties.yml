name: Update Module Properties

# This workflow runs in the modules-untouched repository
# It automatically updates modules/MODULE.properties files when a release is created or edited

on:
  release:
    types: [published, edited]
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to process (e.g., php-2025.10.31)'
        required: true

jobs:
  update-properties:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install requests packaging
      
      - name: Extract module name and update properties
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_TAG: ${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          python << 'EOF'
          import os
          import re
          import requests
          from packaging import version
          from collections import OrderedDict
          
          # Get environment variables
          release_tag = os.environ['RELEASE_TAG']
          repo_owner = os.environ['REPO_OWNER']
          repo_name = os.environ['REPO_NAME']
          github_token = os.environ['GITHUB_TOKEN']
          
          print(f"Processing release: {release_tag}")
          
          # Extract module name from tag (e.g., "php-2025.10.31" -> "php")
          module_match = re.match(r'^([a-zA-Z0-9_-]+)-\d{4}\.\d{1,2}\.\d{1,2}', release_tag)
          if not module_match:
              print(f"ERROR: Could not extract module name from tag: {release_tag}")
              print("Expected format: MODULENAME-YYYY.MM.DD (e.g., php-2025.10.31)")
              exit(1)
          
          module_name = module_match.group(1)
          print(f"Module name: {module_name}")
          
          # Save module name for next steps (do this early in case of errors)
          with open('module_name.txt', 'w') as f:
              f.write(module_name)
          
          # Construct API URL
          api_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/releases/tags/{release_tag}"
          
          headers = {
              'Authorization': f'token {github_token}',
              'Accept': 'application/vnd.github.v3+json'
          }
          
          print(f"Fetching release information from: {api_url}")
          
          # Fetch release data
          response = requests.get(api_url, headers=headers)
          response.raise_for_status()
          release_data = response.json()
          
          # For composer, extract version from release title/name
          composer_version = None
          if module_name == 'composer':
              release_name = release_data.get('name', '')
              # Try to extract version from release name (e.g., "Composer 2.8.4" -> "2.8.4")
              version_match = re.search(r'(\d+\.\d+\.\d+(?:\.\d+)?)', release_name)
              if version_match:
                  composer_version = version_match.group(1)
                  print(f"Extracted composer version from release name: {composer_version}")
          
          # Extract assets
          # Special handling for composer (uses .phar files)
          assets = []
          for asset in release_data.get('assets', []):
              filename = asset['name']
              
              # For composer, accept any .phar file (doesn't need to start with "composer")
              # For other modules, file must start with module name
              if module_name == 'composer':
                  if filename.endswith('.phar'):
                      download_url = asset['browser_download_url']
                      # Use version from release name, or extract from filename
                      if composer_version:
                          ver = composer_version
                      else:
                          version_match = re.search(r'(\d+\.\d+\.\d+(?:\.\d+)?)', filename)
                          if version_match:
                              ver = version_match.group(1)
                          else:
                              print(f"ERROR: Could not extract version for composer from release name or filename: {filename}")
                              print(f"Release name: {release_data.get('name', 'N/A')}")
                              exit(1)
                      assets.append({
                          'version': ver,
                          'url': download_url,
                          'filename': filename
                      })
                      print(f"Found: {filename} -> Version: {ver}")
              elif filename.startswith(module_name):
                  # Standard modules use .7z or .zip and must start with module name
                  if filename.endswith('.7z') or filename.endswith('.zip'):
                      download_url = asset['browser_download_url']
                      
                      # Extract version number (flexible pattern)
                      version_match = re.search(r'(\d+\.\d+\.\d+(?:\.\d+)?)', filename)
                      if version_match:
                          ver = version_match.group(1)
                          assets.append({
                              'version': ver,
                              'url': download_url,
                              'filename': filename
                          })
                          print(f"Found: {filename} -> Version: {ver}")
                      else:
                          print(f"Warning: Could not extract version from: {filename}")
          
          if not assets:
              if module_name == 'composer':
                  print(f"No .phar assets found in release")
                  print(f"Available assets: {[a['name'] for a in release_data.get('assets', [])]}")
              else:
                  print(f"No .7z or .zip assets found starting with '{module_name}' in release")
              exit(0)
          
          # Read existing properties file
          properties_file = f"modules/{module_name}.properties"
          
          if not os.path.exists(properties_file):
              print(f"ERROR: Properties file not found: {properties_file}")
              print(f"The properties file must already exist in the repository.")
              exit(1)
          
          print(f"Reading existing properties file: {properties_file}")
          with open(properties_file, 'r', encoding='utf-8') as f:
              lines = f.readlines()
          
          print(f"File contents ({len(lines)} lines):")
          for i, line in enumerate(lines, 1):
              print(f"  {i}: {line.rstrip()}")
          
          # Parse existing properties
          properties = OrderedDict()
          header_lines = []
          in_header = True
          
          for line in lines:
              stripped = line.strip()
              if in_header and (stripped.startswith('#') or stripped == ''):
                  header_lines.append(line)
              else:
                  in_header = False
                  if '=' in line and not stripped.startswith('#'):
                      key, value = line.split('=', 1)
                      properties[key.strip()] = value.strip()
          
          print(f"\nExisting properties before update: {len(properties)} entries")
          for key, value in properties.items():
              print(f"  {key} = {value}")
          
          # Add new versions
          for asset in assets:
              ver = asset['version']
              url = asset['url']
              
              # Create property key (just version number)
              key = ver
              properties[key] = url
              print(f"Added/Updated: {key} = {url}")
          
          # Sort properties by version (semver)
          def extract_version(key):
              # Parse version directly from key
              try:
                  return version.parse(key)
              except:
                  return version.parse("0.0.0")
          
          sorted_properties = OrderedDict(
              sorted(properties.items(), key=lambda x: extract_version(x[0]), reverse=True)
          )
          
          # Write back to file
          with open(properties_file, 'w', encoding='utf-8') as f:
              # Write header
              for line in header_lines:
                  f.write(line)
              
              # Write sorted properties with spaces around equals sign
              for key, value in sorted_properties.items():
                  f.write(f"{key} = {value}\n")
          
          print(f"\nSuccessfully updated {properties_file}")
          print(f"Total versions: {len(sorted_properties)}")
          
          EOF
      
      - name: Read module name
        id: module_info
        if: always()
        run: |
          if [ -f module_name.txt ]; then
            MODULE_NAME=$(cat module_name.txt)
            echo "module_name=$MODULE_NAME" >> $GITHUB_OUTPUT
          else
            echo "module_name=unknown" >> $GITHUB_OUTPUT
          fi
      
      - name: Check for changes
        id: check_changes
        run: |
          echo "Git status:"
          git status
          echo ""
          echo "Git diff:"
          git diff
          echo ""
          if [[ -n $(git status --porcelain) ]]; then
            echo "Changes detected!"
            echo "changes=true" >> $GITHUB_OUTPUT
          else
            echo "No changes detected"
            echo "changes=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Pull Request
        if: steps.check_changes.outputs.changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GH_PAT }}
          commit-message: |
            Update ${{ steps.module_info.outputs.module_name }} module properties
            
            Auto-generated from release ${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          branch: update-${{ steps.module_info.outputs.module_name }}-${{ github.event.release.tag_name || github.event.inputs.release_tag }}
          delete-branch: true
          title: 'Update ${{ steps.module_info.outputs.module_name }} properties from release ${{ github.event.release.tag_name || github.event.inputs.release_tag }}'
          body: |
            ## ü§ñ Automated Module Properties Update
            
            This PR updates the `${{ steps.module_info.outputs.module_name }}.properties` file with new versions from release `${{ github.event.release.tag_name || github.event.inputs.release_tag }}`.
            
            ### Changes:
            - Extracted assets starting with `${{ steps.module_info.outputs.module_name }}`
            - Added version entries with download URLs
            - Maintained semver ordering (newest first)
            
            **Release URL:** ${{ github.event.release.html_url || format('https://github.com/{0}/{1}/releases/tag/{2}', github.repository_owner, github.event.repository.name, github.event.inputs.release_tag) }}
            
            ### Next Steps:
            1. ‚è≥ Link validation will run automatically
            2. ‚úÖ Once validation passes, this PR will auto-merge
            3. ‚ùå If validation fails, please review and fix invalid URLs
          labels: |
            automated
            module-update
      
      - name: Wait for validation checks
        if: steps.check_changes.outputs.changes == 'true' && steps.create_pr.outputs.pull-request-number != ''
        run: |
          echo "Waiting for link validation to complete..."
          sleep 10
      
      - name: Enable auto-merge
        if: steps.check_changes.outputs.changes == 'true' && steps.create_pr.outputs.pull-request-number != ''
        run: |
          gh pr merge ${{ steps.create_pr.outputs.pull-request-number }} --auto --squash
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
